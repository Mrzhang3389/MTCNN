# 使用
# 创建一个 侦测者类
# 载入三个网络 和 三个网络的权重
# 1.1 创建三个网络
# 1.2 如果使用cuda那么就将网络放入cuda
# 1.3 使用时 batch_normal 和 Dropout 会停用
# 1.4 torch 加个net.eval() 代表使用状态  net.train()代表训练状态
# 1.5 定义了一个网络的开始时间 结束时间 差值就为网络的运行时间
# 1.6 将数据传入 P 网络 返回一批留下来的框 如果没有框 返回一个空数组
# 1.7 将原来的图 和留下来的框传到 R 网络 如果没有框 返回一个空数组
# 1.8 将 R 网络留下来的框 和 原图 传到 O 网络里面去 返回一批框就是最终的结果

# 1.91 (P 网络的侦测)
# # 1.92 定义一个列表用来保存 P 网络的结果
# # 1.93 复制一份图用来做缩放 原图保留
# 1.94 得到复制图的 宽和高 获得 宽和高中的最小值 因为图像金字塔中缩放的最小值不能比网络最小的像素还小
# 1.95 设置一个图像金字塔的比例
# 1.96 判断 图像金字塔最小的都符合 大于12 将图片转为数据 并拷贝到cuda(如果使用的画)
# 1.97 升一个维度 因为要加一个批次 训练的时候是训练的一批, 使用我们只使用了一张 所以需要升一个维度
# 1.98 传入 P 网络里面 得到两个返回值 一个置信度 一个偏值
# 1.99 接下来保留 置信度大于某个阈值的框
# 1.10 图像金字塔 缩放图片 0.7  # 宽和高缩小 0.7
# 1.11 将图像 resize(0.7宽, 0.7高) # 再求一次最小边
# 1.12 NMS阈值0.5
# 1.13 还需要定义一个 box 框 将 建议框映射到原图上 (原理 算上一步框的位置 再除以 缩小的比例)
# 1.131 (映射原图 所需要的 参数: 索引, 偏移量, 置信度, 比例, 步长=2, side_len=12 尺寸大小)  (计算 最后一个视频 1:06:00计算)
# 1.132 P 网络作为一个核的 大小为 12
# 1.14 有了原图以后 做个NMS返回

# 1.15 (R 网络)
# 1.16 P 网络的结果 和 原图一起放进 R 网络
# 1.17 创建一个 列表 用来保存 P 网络框出来的图 抠出来 打成一个批次 传进 R 网络
# 1.18 将图像(有可能是矩形) 扩充成 正方形 (张量计算 将图形的中心点 最长边的边长 计算出 左上点 和 右下点)
# 1.19 将 计算出的两个点 正式在原图中抠出来 缩放成网络需要的大小
# 1.20 将图片转换成 nchw 结构 然后再丢进 R 网络里面去 得到返回值 置信度和偏移量
# 1.21 反算 原图 映射的框 做一个 NMS 传入下一个网络
# 1.22 最小NMS 最后用一次


# 1.23 测试 下载一张图片 打开 创建一个侦测者
# 1.24 把图片丢进网络 得到一批框 把这批框循环 画到图上
# 1.25 打印一下图片 人为观察一下 项目结束
